<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Interactive Shapes</title>
  <!-- 引入Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- 引入Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <!-- 自定义配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',    // 蓝色
            secondary: '#8B5CF6',  // 紫色
            accent: '#EC4899',     // 粉色
            teal: '#14B8A6',       // 青色
            amber: '#F59E0B',      // 琥珀色
            emerald: '#10B981',    // 翠绿色
            rose: '#E11D48',       // 玫瑰红
            indigo: '#6366F1',     // 靛蓝色
            dark: '#0F172A',       // 深色背景
          },
          animation: {
            'float': 'float 6s ease-in-out infinite',
            'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            'spin-slow': 'spin 15s linear infinite',
            'spin-fast': 'spin 5s linear infinite',
            'pulse-soft': 'pulse-soft 3s ease-in-out infinite',
            'scale': 'scale 3s ease-in-out infinite',
          },
          keyframes: {
            float: {
              '0%, 100%': { transform: 'translateY(0) rotate(0deg)' },
              '50%': { transform: 'translateY(-20px) rotate(5deg)' },
            },
            'pulse-soft': {
              '0%, 100%': { opacity: 0.8 },
              '50%': { opacity: 0.4 },
            },
            'scale': {
              '0%, 100%': { transform: 'scale(1)' },
              '50%': { transform: 'scale(1.1)' },
            }
          }
        }
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .shape-transition {
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      .shape-shadow {
        box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
      }
      .clip-triangle {
        clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
      }
      .clip-diamond {
        clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
      }
      .clip-star {
        clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      }
      .clip-hexagon {
        clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
      }
      .clip-cross {
        clip-path: polygon(20% 0%, 0% 20%, 30% 50%, 0% 80%, 20% 100%, 50% 70%, 80% 100%, 100% 80%, 70% 50%, 100% 20%, 80% 0%, 50% 30%);
      }
      .bg-gradient-1 {
        background: linear-gradient(135deg, #3B82F6, #8B5CF6);
      }
      .bg-gradient-2 {
        background: linear-gradient(135deg, #EC4899, #F59E0B);
      }
      .bg-gradient-3 {
        background: linear-gradient(135deg, #14B8A6, #10B981);
      }
      .bg-gradient-4 {
        background: linear-gradient(135deg, #6366F1, #E11D48);
      }
    }
  </style>
</head>

<body class="overflow-hidden bg-dark min-h-screen">
  <div id="shape-container" class="relative w-full h-screen overflow-hidden">
    <!-- 背景装饰元素 -->
    <div class="absolute inset-0 z-0 opacity-10">
      <div class="absolute top-1/4 left-1/4 w-96 h-96 rounded-full bg-primary blur-3xl animate-pulse-slow"></div>
      <div class="absolute top-3/4 left-2/3 w-80 h-80 rounded-full bg-secondary blur-3xl animate-pulse-slow" style="animation-delay: 1s"></div>
      <div class="absolute top-1/2 left-1/3 w-64 h-64 rounded-full bg-accent blur-3xl animate-pulse-slow" style="animation-delay: 2s"></div>
      <div class="absolute top-1/5 right-1/4 w-72 h-72 rounded-full bg-teal blur-3xl animate-pulse-slow" style="animation-delay: 1.5s"></div>
    </div>

    <!-- 图形将通过JS动态生成 -->
  </div>

  <script>
    // 配置参数
    const config = {
      shapeCount: 40,          // 图形总数
      minSize: 20,             // 最小尺寸
      maxSize: 140,            // 最大尺寸
      shapes: [
        'circle', 'square', 'triangle', 'diamond', 
        'star', 'hexagon', 'cross'  // 新增图形
      ],
      colors: [
        'primary', 'secondary', 'accent', 'teal', 
        'amber', 'emerald', 'rose', 'indigo',
        'gradient-1', 'gradient-2', 'gradient-3', 'gradient-4'  // 新增渐变色
      ],
      hoverScale: 1.4,         // 悬停缩放比例
      followFactor: 0.02,      // 跟随鼠标因子
      repelDistance: 200,      // 排斥距离
      repelStrength: 0.5       // 排斥强度
    };

    // 获取容器
    const container = document.getElementById('shape-container');
    let mouseX = window.innerWidth / 2;
    let mouseY = window.innerHeight / 2;
    let isMouseDown = false;

    // 生成随机数
    const getRandom = (min, max) => Math.random() * (max - min) + min;
    const getRandomInt = (min, max) => Math.floor(getRandom(min, max));
    const getRandomSign = () => Math.random() > 0.5 ? 1 : -1;

    // 创建单个图形
    const createShape = () => {
      // 随机配置
      const shapeType = config.shapes[getRandomInt(0, config.shapes.length)];
      const colorType = config.colors[getRandomInt(0, config.colors.length)];
      const size = getRandom(config.minSize, config.maxSize);
      const initialX = getRandom(0, window.innerWidth - size);
      const initialY = getRandom(0, window.innerHeight - size);
      const delay = getRandom(0, 5);  // 动画延迟
      const floatDuration = getRandom(4, 10);  // 浮动动画时长
      const rotation = getRandom(0, 360);  // 初始旋转角度
      const rotationSpeed = getRandom(-1, 1);  // 旋转速度

      // 创建元素
      const shape = document.createElement('div');
      shape.classList.add('absolute', 'shape-transition', 'shape-shadow', 'cursor-pointer', 'z-10');
      
      // 设置尺寸
      shape.style.width = `${size}px`;
      shape.style.height = `${size}px`;
      
      // 设置初始位置
      shape.style.left = `${initialX}px`;
      shape.style.top = `${initialY}px`;
      
      // 设置初始旋转
      shape.style.transform = `rotate(${rotation}deg)`;
      
      // 设置颜色
      if (colorType.startsWith('gradient')) {
        shape.classList.add(`bg-${colorType}`);
      } else {
        shape.classList.add(`bg-${colorType}/80`, `hover:bg-${colorType}`);
      }
      
      // 设置形状
      switch(shapeType) {
        case 'circle':
          shape.classList.add('rounded-full');
          break;
        case 'square':
          shape.classList.add('rounded-sm');
          break;
        case 'triangle':
          shape.classList.add('clip-triangle');
          break;
        case 'diamond':
          shape.classList.add('clip-diamond');
          break;
        case 'star':
          shape.classList.add('clip-star');
          break;
        case 'hexagon':
          shape.classList.add('clip-hexagon');
          break;
        case 'cross':
          shape.classList.add('clip-cross');
          break;
      }
      
      // 随机动画
      const animations = ['float', 'spin-slow', 'spin-fast', 'pulse-soft', 'scale', 'none'];
      const animation = animations[getRandomInt(0, animations.length)];
      if (animation !== 'none') {
        shape.style.animation = `${animation} ${floatDuration}s ease-in-out infinite ${delay}s`;
      }
      
      // 存储初始属性
      shape.dataset.initialX = initialX;
      shape.dataset.initialY = initialY;
      shape.dataset.size = size;
      shape.dataset.rotation = rotation;
      shape.dataset.rotationSpeed = rotationSpeed;
      shape.dataset.isExploding = 'false';

      // 悬停效果
      shape.addEventListener('mouseenter', () => {
        if (shape.dataset.isExploding === 'false') {
          shape.style.transform = `scale(${config.hoverScale}) rotate(${rotation}deg)`;
          shape.style.zIndex = '20';
          shape.classList.add('shadow-2xl');
        }
      });

      shape.addEventListener('mouseleave', () => {
        if (shape.dataset.isExploding === 'false') {
          shape.style.transform = `scale(1) rotate(${rotation}deg)`;
          shape.style.zIndex = '10';
          shape.classList.remove('shadow-2xl');
        }
      });

      // 点击效果 - 爆炸/分裂
      shape.addEventListener('click', () => {
        if (shape.dataset.isExploding === 'false') {
          shape.dataset.isExploding = 'true';
          explodeShape(shape);
        }
      });

      return shape;
    };

    // 图形爆炸效果
    const explodeShape = (shape) => {
      const size = parseFloat(shape.dataset.size);
      const x = parseFloat(shape.style.left);
      const y = parseFloat(shape.style.top);
      const color = shape.classList[3]; // 获取颜色类
      
      // 创建碎片
      const fragmentCount = getRandomInt(5, 10);
      for (let i = 0; i < fragmentCount; i++) {
        const fragment = document.createElement('div');
        const fragmentSize = getRandom(size / 8, size / 3);
        
        fragment.classList.add('absolute', 'shape-shadow');
        fragment.style.width = `${fragmentSize}px`;
        fragment.style.height = `${fragmentSize}px`;
        fragment.style.left = `${x + size/2 - fragmentSize/2}px`;
        fragment.style.top = `${y + size/2 - fragmentSize/2}px`;
        fragment.classList.add(color);
        
        // 随机形状
        const fragmentShapes = ['rounded-full', 'rounded-sm', 'clip-triangle', 'clip-diamond'];
        fragment.classList.add(fragmentShapes[getRandomInt(0, fragmentShapes.length)]);
        
        // 随机方向和距离
        const angle = getRandom(0, Math.PI * 2);
        const distance = getRandom(size/2, size);
        const vx = Math.cos(angle) * distance;
        const vy = Math.sin(angle) * distance;
        
        // 动画
        fragment.style.transition = 'all 0.8s cubic-bezier(0.17, 0.67, 0.83, 0.67)';
        container.appendChild(fragment);
        
        // 触发动画
        setTimeout(() => {
          fragment.style.transform = `translate(${vx}px, ${vy}px) rotate(${getRandom(0, 360)}deg)`;
          fragment.style.opacity = '0';
        }, 10);
        
        // 移除碎片
        setTimeout(() => {
          fragment.remove();
        }, 800);
      }
      
      // 隐藏原图形并移除
      shape.style.opacity = '0';
      setTimeout(() => {
        shape.remove();
        // 补充新图形
        container.appendChild(createShape());
      }, 300);
    };

    // 生成所有图形
    const generateShapes = () => {
      // 清除现有图形
      while (container.children.length > 1) {
        container.removeChild(container.lastChild);
      }
      
      // 生成新图形
      for (let i = 0; i < config.shapeCount; i++) {
        const shape = createShape();
        container.appendChild(shape);
      }
    };

    // 鼠标事件
    window.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    window.addEventListener('mousedown', () => {
      isMouseDown = true;
    });

    window.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    // 更新图形位置和状态
    const updateShapes = () => {
      const shapes = document.querySelectorAll('.absolute.shape-transition');
      
      shapes.forEach(shape => {
        if (shape.dataset.isExploding === 'true') return;
        
        const initialX = parseFloat(shape.dataset.initialX);
        const initialY = parseFloat(shape.dataset.initialY);
        const size = parseFloat(shape.dataset.size);
        const rotation = parseFloat(shape.dataset.rotation);
        const rotationSpeed = parseFloat(shape.dataset.rotationSpeed);
        
        // 计算当前位置
        let currentX = parseFloat(shape.style.left);
        let currentY = parseFloat(shape.style.top);
        
        // 鼠标跟随效果
        const followOffsetX = (mouseX - window.innerWidth / 2) * config.followFactor;
        const followOffsetY = (mouseY - window.innerHeight / 2) * config.followFactor;
        
        // 鼠标排斥/吸引效果
        const shapeCenterX = currentX + size / 2;
        const shapeCenterY = currentY + size / 2;
        const dx = mouseX - shapeCenterX;
        const dy = mouseY - shapeCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        let repelOffsetX = 0;
        let repelOffsetY = 0;
        
        // 当鼠标按下时吸引，否则排斥
        if (distance < config.repelDistance) {
          const force = (1 - distance / config.repelDistance) * config.repelStrength;
          const angle = Math.atan2(dy, dx);
          
          if (isMouseDown) {
            // 吸引
            repelOffsetX = Math.cos(angle) * force * 30;
            repelOffsetY = Math.sin(angle) * force * 30;
          } else {
            // 排斥
            repelOffsetX = -Math.cos(angle) * force * 50;
            repelOffsetY = -Math.sin(angle) * force * 50;
          }
        }
        
        // 应用旋转
        const newRotation = rotation + rotationSpeed;
        shape.dataset.rotation = newRotation;
        
        // 更新位置和旋转
        const targetX = initialX + followOffsetX + repelOffsetX;
        const targetY = initialY + followOffsetY + repelOffsetY;
        
        // 边界检查
        const boundedX = Math.max(0, Math.min(window.innerWidth - size, targetX));
        const boundedY = Math.max(0, Math.min(window.innerHeight - size, targetY));
        
        shape.style.left = `${boundedX}px`;
        shape.style.top = `${boundedY}px`;
        
        // 维持缩放状态的同时应用旋转
        const scale = shape.style.transform.includes('scale') ? config.hoverScale : 1;
        shape.style.transform = `scale(${scale}) rotate(${newRotation}deg)`;
      });

      requestAnimationFrame(updateShapes);
    };

    // 窗口 resize 处理
    window.addEventListener('resize', () => {
      generateShapes();
    });

    // 初始化
    generateShapes();
    updateShapes();
  </script>
</body>
</html>
